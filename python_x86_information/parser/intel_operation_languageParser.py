# Generated from intel_operation_language.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,54,266,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,1,0,
        5,0,42,8,0,10,0,12,0,45,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,4,1,61,8,1,11,1,12,1,62,1,1,1,1,1,1,3,1,68,8,
        1,1,2,1,2,1,2,4,2,73,8,2,11,2,12,2,74,1,3,1,3,1,3,1,3,1,3,1,3,1,
        3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,
        3,99,8,3,1,4,1,4,1,4,4,4,104,8,4,11,4,12,4,105,1,4,1,4,4,4,110,8,
        4,11,4,12,4,111,3,4,114,8,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,4,5,123,
        8,5,11,5,12,5,124,1,5,1,5,1,6,1,6,1,7,1,7,1,7,1,7,4,7,135,8,7,11,
        7,12,7,136,1,7,1,7,4,7,141,8,7,11,7,12,7,142,1,7,1,7,1,8,1,8,1,9,
        1,9,3,9,151,8,9,1,9,1,9,5,9,155,8,9,10,9,12,9,158,9,9,1,9,1,9,1,
        10,1,10,3,10,164,8,10,1,11,1,11,3,11,168,8,11,1,11,1,11,3,11,172,
        8,11,1,11,1,11,4,11,176,8,11,11,11,12,11,177,1,11,1,11,1,12,1,12,
        1,12,1,12,1,13,1,13,1,13,1,13,4,13,190,8,13,11,13,12,13,191,1,13,
        1,13,1,13,1,13,1,14,1,14,1,15,1,15,3,15,202,8,15,1,15,1,15,1,15,
        3,15,207,8,15,1,16,4,16,210,8,16,11,16,12,16,211,1,16,3,16,215,8,
        16,1,16,1,16,3,16,219,8,16,1,17,1,17,4,17,223,8,17,11,17,12,17,224,
        1,17,1,17,4,17,229,8,17,11,17,12,17,230,3,17,233,8,17,1,17,1,17,
        1,18,1,18,3,18,239,8,18,1,18,3,18,242,8,18,1,19,1,19,1,19,1,19,1,
        19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,
        19,1,19,1,19,3,19,264,8,19,1,19,0,0,20,0,2,4,6,8,10,12,14,16,18,
        20,22,24,26,28,30,32,34,36,38,0,2,1,0,40,41,2,0,14,14,18,18,301,
        0,43,1,0,0,0,2,67,1,0,0,0,4,69,1,0,0,0,6,98,1,0,0,0,8,100,1,0,0,
        0,10,117,1,0,0,0,12,128,1,0,0,0,14,130,1,0,0,0,16,146,1,0,0,0,18,
        148,1,0,0,0,20,161,1,0,0,0,22,165,1,0,0,0,24,181,1,0,0,0,26,185,
        1,0,0,0,28,197,1,0,0,0,30,201,1,0,0,0,32,209,1,0,0,0,34,220,1,0,
        0,0,36,241,1,0,0,0,38,263,1,0,0,0,40,42,3,2,1,0,41,40,1,0,0,0,42,
        45,1,0,0,0,43,41,1,0,0,0,43,44,1,0,0,0,44,46,1,0,0,0,45,43,1,0,0,
        0,46,47,5,0,0,1,47,1,1,0,0,0,48,68,5,52,0,0,49,68,3,8,4,0,50,68,
        3,10,5,0,51,68,3,14,7,0,52,68,3,18,9,0,53,68,3,22,11,0,54,68,3,26,
        13,0,55,68,3,6,3,0,56,68,3,32,16,0,57,68,3,38,19,0,58,60,5,3,0,0,
        59,61,3,2,1,0,60,59,1,0,0,0,61,62,1,0,0,0,62,60,1,0,0,0,62,63,1,
        0,0,0,63,64,1,0,0,0,64,65,5,4,0,0,65,68,1,0,0,0,66,68,3,4,2,0,67,
        48,1,0,0,0,67,49,1,0,0,0,67,50,1,0,0,0,67,51,1,0,0,0,67,52,1,0,0,
        0,67,53,1,0,0,0,67,54,1,0,0,0,67,55,1,0,0,0,67,56,1,0,0,0,67,57,
        1,0,0,0,67,58,1,0,0,0,67,66,1,0,0,0,68,3,1,0,0,0,69,70,3,32,16,0,
        70,72,5,11,0,0,71,73,3,2,1,0,72,71,1,0,0,0,73,74,1,0,0,0,74,72,1,
        0,0,0,74,75,1,0,0,0,75,5,1,0,0,0,76,77,5,3,0,0,77,78,3,30,15,0,78,
        79,5,7,0,0,79,80,3,2,1,0,80,81,5,8,0,0,81,82,3,2,1,0,82,83,5,4,0,
        0,83,99,1,0,0,0,84,85,5,3,0,0,85,86,3,30,15,0,86,87,5,4,0,0,87,88,
        5,7,0,0,88,89,3,2,1,0,89,90,5,8,0,0,90,91,3,2,1,0,91,99,1,0,0,0,
        92,93,3,30,15,0,93,94,5,7,0,0,94,95,3,2,1,0,95,96,5,8,0,0,96,97,
        3,2,1,0,97,99,1,0,0,0,98,76,1,0,0,0,98,84,1,0,0,0,98,92,1,0,0,0,
        99,7,1,0,0,0,100,101,5,36,0,0,101,103,3,30,15,0,102,104,3,2,1,0,
        103,102,1,0,0,0,104,105,1,0,0,0,105,103,1,0,0,0,105,106,1,0,0,0,
        106,113,1,0,0,0,107,109,5,38,0,0,108,110,3,2,1,0,109,108,1,0,0,0,
        110,111,1,0,0,0,111,109,1,0,0,0,111,112,1,0,0,0,112,114,1,0,0,0,
        113,107,1,0,0,0,113,114,1,0,0,0,114,115,1,0,0,0,115,116,5,37,0,0,
        116,9,1,0,0,0,117,118,5,39,0,0,118,119,3,4,2,0,119,120,7,0,0,0,120,
        122,3,2,1,0,121,123,3,12,6,0,122,121,1,0,0,0,123,124,1,0,0,0,124,
        122,1,0,0,0,124,125,1,0,0,0,125,126,1,0,0,0,126,127,5,42,0,0,127,
        11,1,0,0,0,128,129,3,2,1,0,129,13,1,0,0,0,130,131,5,43,0,0,131,132,
        5,44,0,0,132,134,5,3,0,0,133,135,3,2,1,0,134,133,1,0,0,0,135,136,
        1,0,0,0,136,134,1,0,0,0,136,137,1,0,0,0,137,138,1,0,0,0,138,140,
        5,4,0,0,139,141,3,16,8,0,140,139,1,0,0,0,141,142,1,0,0,0,142,140,
        1,0,0,0,142,143,1,0,0,0,143,144,1,0,0,0,144,145,5,45,0,0,145,15,
        1,0,0,0,146,147,3,2,1,0,147,17,1,0,0,0,148,150,5,51,0,0,149,151,
        5,52,0,0,150,149,1,0,0,0,150,151,1,0,0,0,151,152,1,0,0,0,152,156,
        5,3,0,0,153,155,3,20,10,0,154,153,1,0,0,0,155,158,1,0,0,0,156,154,
        1,0,0,0,156,157,1,0,0,0,157,159,1,0,0,0,158,156,1,0,0,0,159,160,
        5,4,0,0,160,19,1,0,0,0,161,163,3,2,1,0,162,164,5,9,0,0,163,162,1,
        0,0,0,163,164,1,0,0,0,164,21,1,0,0,0,165,167,5,46,0,0,166,168,5,
        3,0,0,167,166,1,0,0,0,167,168,1,0,0,0,168,169,1,0,0,0,169,171,3,
        2,1,0,170,172,5,4,0,0,171,170,1,0,0,0,171,172,1,0,0,0,172,173,1,
        0,0,0,173,175,5,48,0,0,174,176,3,24,12,0,175,174,1,0,0,0,176,177,
        1,0,0,0,177,175,1,0,0,0,177,178,1,0,0,0,178,179,1,0,0,0,179,180,
        5,47,0,0,180,23,1,0,0,0,181,182,3,2,1,0,182,183,5,8,0,0,183,184,
        3,2,1,0,184,25,1,0,0,0,185,186,5,49,0,0,186,187,3,18,9,0,187,189,
        5,5,0,0,188,190,3,2,1,0,189,188,1,0,0,0,190,191,1,0,0,0,191,189,
        1,0,0,0,191,192,1,0,0,0,192,193,1,0,0,0,193,194,5,50,0,0,194,195,
        3,28,14,0,195,196,5,6,0,0,196,27,1,0,0,0,197,198,3,2,1,0,198,29,
        1,0,0,0,199,202,3,32,16,0,200,202,5,52,0,0,201,199,1,0,0,0,201,200,
        1,0,0,0,202,203,1,0,0,0,203,206,3,38,19,0,204,207,3,32,16,0,205,
        207,5,52,0,0,206,204,1,0,0,0,206,205,1,0,0,0,207,31,1,0,0,0,208,
        210,5,51,0,0,209,208,1,0,0,0,210,211,1,0,0,0,211,209,1,0,0,0,211,
        212,1,0,0,0,212,214,1,0,0,0,213,215,3,34,17,0,214,213,1,0,0,0,214,
        215,1,0,0,0,215,218,1,0,0,0,216,217,5,10,0,0,217,219,3,32,16,0,218,
        216,1,0,0,0,218,219,1,0,0,0,219,33,1,0,0,0,220,222,5,1,0,0,221,223,
        3,36,18,0,222,221,1,0,0,0,223,224,1,0,0,0,224,222,1,0,0,0,224,225,
        1,0,0,0,225,232,1,0,0,0,226,228,5,8,0,0,227,229,3,36,18,0,228,227,
        1,0,0,0,229,230,1,0,0,0,230,228,1,0,0,0,230,231,1,0,0,0,231,233,
        1,0,0,0,232,226,1,0,0,0,232,233,1,0,0,0,233,234,1,0,0,0,234,235,
        5,2,0,0,235,35,1,0,0,0,236,239,3,32,16,0,237,239,5,52,0,0,238,236,
        1,0,0,0,238,237,1,0,0,0,239,242,1,0,0,0,240,242,7,1,0,0,241,238,
        1,0,0,0,241,240,1,0,0,0,242,37,1,0,0,0,243,264,5,14,0,0,244,264,
        5,16,0,0,245,264,5,12,0,0,246,264,5,18,0,0,247,264,5,19,0,0,248,
        264,5,20,0,0,249,264,5,30,0,0,250,264,5,32,0,0,251,264,5,13,0,0,
        252,253,5,30,0,0,253,264,5,12,0,0,254,255,5,32,0,0,255,264,5,12,
        0,0,256,264,5,21,0,0,257,264,5,22,0,0,258,264,5,28,0,0,259,264,5,
        26,0,0,260,264,5,27,0,0,261,264,5,23,0,0,262,264,5,17,0,0,263,243,
        1,0,0,0,263,244,1,0,0,0,263,245,1,0,0,0,263,246,1,0,0,0,263,247,
        1,0,0,0,263,248,1,0,0,0,263,249,1,0,0,0,263,250,1,0,0,0,263,251,
        1,0,0,0,263,252,1,0,0,0,263,254,1,0,0,0,263,256,1,0,0,0,263,257,
        1,0,0,0,263,258,1,0,0,0,263,259,1,0,0,0,263,260,1,0,0,0,263,261,
        1,0,0,0,263,262,1,0,0,0,264,39,1,0,0,0,29,43,62,67,74,98,105,111,
        113,124,136,142,150,156,163,167,171,177,191,201,206,211,214,218,
        224,230,232,238,241,263
    ]

class intel_operation_languageParser ( Parser ):

    grammarFileName = "intel_operation_language.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'['", "']'", "'('", "')'", "'{'", "'}'", 
                     "'?'", "':'", "','", "'.'", "':='", "'='", "'=='", 
                     "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", 
                     "'&'", "'|'", "'&&'", "'||'", "'^'", "'XOR'", "'AND'", 
                     "'!'", "'~'", "'<'", "'<='", "'>'", "'>='", "'<<'", 
                     "'>>'", "'IF'", "'FI'", "'ELSE'", "'FOR'", "'to'", 
                     "'TO'", "'ENDFOR'", "'DO'", "'WHILE'", "'OD'", "'CASE'", 
                     "'ESAC'", "'OF'", "'DEFINE'", "'RETURN'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "LeftParen", 
                      "RightParen", "CurlyLeft", "CurlyRight", "Question", 
                      "Colon", "Comma", "Dot", "Assign", "Equal", "EqualEqual", 
                      "Plus", "PlusPlus", "Minus", "MinusMinus", "Star", 
                      "Div", "Mod", "And", "Or", "AndAnd", "OrOr", "Caret", 
                      "XOR", "AND", "Not", "Tilde", "Less", "LessEqual", 
                      "Greater", "GreaterEqual", "LeftShift", "RightShift", 
                      "IF", "FI", "ELSE", "FOR", "TO", "TO2", "ENDFOR", 
                      "DO", "WHILE", "OD", "CASE", "ESAC", "OF", "DEFINE", 
                      "RETURN", "NAME", "INT", "LineComment", "WS" ]

    RULE_prog = 0
    RULE_expression = 1
    RULE_definitionExpression = 2
    RULE_ternaryoperator = 3
    RULE_ifExpression = 4
    RULE_forExpression = 5
    RULE_forExpressionExpression = 6
    RULE_doWhileExpression = 7
    RULE_doWhileExpressionExpression = 8
    RULE_functionExpression = 9
    RULE_functionExpressionArgument = 10
    RULE_caseExpression = 11
    RULE_caseExpressionExpression = 12
    RULE_defineExpression = 13
    RULE_returnExpression = 14
    RULE_comparison = 15
    RULE_variable = 16
    RULE_accessoperator = 17
    RULE_accessoperatorname = 18
    RULE_operator = 19

    ruleNames =  [ "prog", "expression", "definitionExpression", "ternaryoperator", 
                   "ifExpression", "forExpression", "forExpressionExpression", 
                   "doWhileExpression", "doWhileExpressionExpression", "functionExpression", 
                   "functionExpressionArgument", "caseExpression", "caseExpressionExpression", 
                   "defineExpression", "returnExpression", "comparison", 
                   "variable", "accessoperator", "accessoperatorname", "operator" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    LeftParen=3
    RightParen=4
    CurlyLeft=5
    CurlyRight=6
    Question=7
    Colon=8
    Comma=9
    Dot=10
    Assign=11
    Equal=12
    EqualEqual=13
    Plus=14
    PlusPlus=15
    Minus=16
    MinusMinus=17
    Star=18
    Div=19
    Mod=20
    And=21
    Or=22
    AndAnd=23
    OrOr=24
    Caret=25
    XOR=26
    AND=27
    Not=28
    Tilde=29
    Less=30
    LessEqual=31
    Greater=32
    GreaterEqual=33
    LeftShift=34
    RightShift=35
    IF=36
    FI=37
    ELSE=38
    FOR=39
    TO=40
    TO2=41
    ENDFOR=42
    DO=43
    WHILE=44
    OD=45
    CASE=46
    ESAC=47
    OF=48
    DEFINE=49
    RETURN=50
    NAME=51
    INT=52
    LineComment=53
    WS=54

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(intel_operation_languageParser.EOF, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = intel_operation_languageParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 43
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0):
                self.state = 40
                self.expression()
                self.state = 45
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 46
            self.match(intel_operation_languageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(intel_operation_languageParser.INT, 0)

        def ifExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.IfExpressionContext,0)


        def forExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ForExpressionContext,0)


        def doWhileExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.DoWhileExpressionContext,0)


        def functionExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.FunctionExpressionContext,0)


        def caseExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.CaseExpressionContext,0)


        def defineExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.DefineExpressionContext,0)


        def ternaryoperator(self):
            return self.getTypedRuleContext(intel_operation_languageParser.TernaryoperatorContext,0)


        def variable(self):
            return self.getTypedRuleContext(intel_operation_languageParser.VariableContext,0)


        def operator(self):
            return self.getTypedRuleContext(intel_operation_languageParser.OperatorContext,0)


        def LeftParen(self):
            return self.getToken(intel_operation_languageParser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(intel_operation_languageParser.RightParen, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def definitionExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.DefinitionExpressionContext,0)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = intel_operation_languageParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_expression)
        self._la = 0 # Token type
        try:
            self.state = 67
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.match(intel_operation_languageParser.INT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 49
                self.ifExpression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 50
                self.forExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 51
                self.doWhileExpression()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 52
                self.functionExpression()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 53
                self.caseExpression()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 54
                self.defineExpression()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 55
                self.ternaryoperator()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 56
                self.variable()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 57
                self.operator()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 58
                self.match(intel_operation_languageParser.LeftParen)
                self.state = 60 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 59
                    self.expression()
                    self.state = 62 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                        break

                self.state = 64
                self.match(intel_operation_languageParser.RightParen)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 66
                self.definitionExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefinitionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(intel_operation_languageParser.VariableContext,0)


        def Assign(self):
            return self.getToken(intel_operation_languageParser.Assign, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_definitionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefinitionExpression" ):
                listener.enterDefinitionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefinitionExpression" ):
                listener.exitDefinitionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefinitionExpression" ):
                return visitor.visitDefinitionExpression(self)
            else:
                return visitor.visitChildren(self)




    def definitionExpression(self):

        localctx = intel_operation_languageParser.DefinitionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_definitionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 69
            self.variable()
            self.state = 70
            self.match(intel_operation_languageParser.Assign)
            self.state = 72 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 71
                    self.expression()

                else:
                    raise NoViableAltException(self)
                self.state = 74 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TernaryoperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(intel_operation_languageParser.LeftParen, 0)

        def comparison(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ComparisonContext,0)


        def Question(self):
            return self.getToken(intel_operation_languageParser.Question, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def Colon(self):
            return self.getToken(intel_operation_languageParser.Colon, 0)

        def RightParen(self):
            return self.getToken(intel_operation_languageParser.RightParen, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_ternaryoperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryoperator" ):
                listener.enterTernaryoperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryoperator" ):
                listener.exitTernaryoperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTernaryoperator" ):
                return visitor.visitTernaryoperator(self)
            else:
                return visitor.visitChildren(self)




    def ternaryoperator(self):

        localctx = intel_operation_languageParser.TernaryoperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ternaryoperator)
        try:
            self.state = 98
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 76
                self.match(intel_operation_languageParser.LeftParen)
                self.state = 77
                self.comparison()
                self.state = 78
                self.match(intel_operation_languageParser.Question)
                self.state = 79
                self.expression()
                self.state = 80
                self.match(intel_operation_languageParser.Colon)
                self.state = 81
                self.expression()
                self.state = 82
                self.match(intel_operation_languageParser.RightParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.match(intel_operation_languageParser.LeftParen)
                self.state = 85
                self.comparison()
                self.state = 86
                self.match(intel_operation_languageParser.RightParen)
                self.state = 87
                self.match(intel_operation_languageParser.Question)
                self.state = 88
                self.expression()
                self.state = 89
                self.match(intel_operation_languageParser.Colon)
                self.state = 90
                self.expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 92
                self.comparison()
                self.state = 93
                self.match(intel_operation_languageParser.Question)
                self.state = 94
                self.expression()
                self.state = 95
                self.match(intel_operation_languageParser.Colon)
                self.state = 96
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(intel_operation_languageParser.IF, 0)

        def comparison(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ComparisonContext,0)


        def FI(self):
            return self.getToken(intel_operation_languageParser.FI, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def ELSE(self):
            return self.getToken(intel_operation_languageParser.ELSE, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_ifExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExpression" ):
                listener.enterIfExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExpression" ):
                listener.exitIfExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExpression" ):
                return visitor.visitIfExpression(self)
            else:
                return visitor.visitChildren(self)




    def ifExpression(self):

        localctx = intel_operation_languageParser.IfExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_ifExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(intel_operation_languageParser.IF)
            self.state = 101
            self.comparison()
            self.state = 103 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 102
                self.expression()
                self.state = 105 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 107
                self.match(intel_operation_languageParser.ELSE)
                self.state = 109 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 108
                    self.expression()
                    self.state = 111 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                        break



            self.state = 115
            self.match(intel_operation_languageParser.FI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(intel_operation_languageParser.FOR, 0)

        def definitionExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.DefinitionExpressionContext,0)


        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def ENDFOR(self):
            return self.getToken(intel_operation_languageParser.ENDFOR, 0)

        def TO(self):
            return self.getToken(intel_operation_languageParser.TO, 0)

        def TO2(self):
            return self.getToken(intel_operation_languageParser.TO2, 0)

        def forExpressionExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ForExpressionExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ForExpressionExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_forExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForExpression" ):
                listener.enterForExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForExpression" ):
                listener.exitForExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForExpression" ):
                return visitor.visitForExpression(self)
            else:
                return visitor.visitChildren(self)




    def forExpression(self):

        localctx = intel_operation_languageParser.ForExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_forExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117
            self.match(intel_operation_languageParser.FOR)
            self.state = 118
            self.definitionExpression()
            self.state = 119
            _la = self._input.LA(1)
            if not(_la==40 or _la==41):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 120
            self.expression()
            self.state = 122 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 121
                self.forExpressionExpression()
                self.state = 124 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 126
            self.match(intel_operation_languageParser.ENDFOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForExpressionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_forExpressionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForExpressionExpression" ):
                listener.enterForExpressionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForExpressionExpression" ):
                listener.exitForExpressionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForExpressionExpression" ):
                return visitor.visitForExpressionExpression(self)
            else:
                return visitor.visitChildren(self)




    def forExpressionExpression(self):

        localctx = intel_operation_languageParser.ForExpressionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_forExpressionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoWhileExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(intel_operation_languageParser.DO, 0)

        def WHILE(self):
            return self.getToken(intel_operation_languageParser.WHILE, 0)

        def LeftParen(self):
            return self.getToken(intel_operation_languageParser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(intel_operation_languageParser.RightParen, 0)

        def OD(self):
            return self.getToken(intel_operation_languageParser.OD, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def doWhileExpressionExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.DoWhileExpressionExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.DoWhileExpressionExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_doWhileExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoWhileExpression" ):
                listener.enterDoWhileExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoWhileExpression" ):
                listener.exitDoWhileExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoWhileExpression" ):
                return visitor.visitDoWhileExpression(self)
            else:
                return visitor.visitChildren(self)




    def doWhileExpression(self):

        localctx = intel_operation_languageParser.DoWhileExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_doWhileExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            self.match(intel_operation_languageParser.DO)
            self.state = 131
            self.match(intel_operation_languageParser.WHILE)
            self.state = 132
            self.match(intel_operation_languageParser.LeftParen)
            self.state = 134 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 133
                self.expression()
                self.state = 136 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 138
            self.match(intel_operation_languageParser.RightParen)
            self.state = 140 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 139
                self.doWhileExpressionExpression()
                self.state = 142 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 144
            self.match(intel_operation_languageParser.OD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoWhileExpressionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_doWhileExpressionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoWhileExpressionExpression" ):
                listener.enterDoWhileExpressionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoWhileExpressionExpression" ):
                listener.exitDoWhileExpressionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoWhileExpressionExpression" ):
                return visitor.visitDoWhileExpressionExpression(self)
            else:
                return visitor.visitChildren(self)




    def doWhileExpressionExpression(self):

        localctx = intel_operation_languageParser.DoWhileExpressionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_doWhileExpressionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LeftParen(self):
            return self.getToken(intel_operation_languageParser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(intel_operation_languageParser.RightParen, 0)

        def NAME(self):
            return self.getToken(intel_operation_languageParser.NAME, 0)

        def functionExpressionArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.FunctionExpressionArgumentContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.FunctionExpressionArgumentContext,i)


        def INT(self):
            return self.getToken(intel_operation_languageParser.INT, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_functionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpression" ):
                listener.enterFunctionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpression" ):
                listener.exitFunctionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionExpression" ):
                return visitor.visitFunctionExpression(self)
            else:
                return visitor.visitChildren(self)




    def functionExpression(self):

        localctx = intel_operation_languageParser.FunctionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_functionExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(intel_operation_languageParser.NAME)
            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==52:
                self.state = 149
                self.match(intel_operation_languageParser.INT)


            self.state = 152
            self.match(intel_operation_languageParser.LeftParen)
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0):
                self.state = 153
                self.functionExpressionArgument()
                self.state = 158
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 159
            self.match(intel_operation_languageParser.RightParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionExpressionArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def Comma(self):
            return self.getToken(intel_operation_languageParser.Comma, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_functionExpressionArgument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionExpressionArgument" ):
                listener.enterFunctionExpressionArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionExpressionArgument" ):
                listener.exitFunctionExpressionArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionExpressionArgument" ):
                return visitor.visitFunctionExpressionArgument(self)
            else:
                return visitor.visitChildren(self)




    def functionExpressionArgument(self):

        localctx = intel_operation_languageParser.FunctionExpressionArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_functionExpressionArgument)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.expression()
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 162
                self.match(intel_operation_languageParser.Comma)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(intel_operation_languageParser.CASE, 0)

        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def OF(self):
            return self.getToken(intel_operation_languageParser.OF, 0)

        def ESAC(self):
            return self.getToken(intel_operation_languageParser.ESAC, 0)

        def LeftParen(self):
            return self.getToken(intel_operation_languageParser.LeftParen, 0)

        def RightParen(self):
            return self.getToken(intel_operation_languageParser.RightParen, 0)

        def caseExpressionExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.CaseExpressionExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.CaseExpressionExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = intel_operation_languageParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(intel_operation_languageParser.CASE)
            self.state = 167
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 166
                self.match(intel_operation_languageParser.LeftParen)


            self.state = 169
            self.expression()
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==4:
                self.state = 170
                self.match(intel_operation_languageParser.RightParen)


            self.state = 173
            self.match(intel_operation_languageParser.OF)
            self.state = 175 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 174
                self.caseExpressionExpression()
                self.state = 177 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 179
            self.match(intel_operation_languageParser.ESAC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def Colon(self):
            return self.getToken(intel_operation_languageParser.Colon, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_caseExpressionExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpressionExpression" ):
                listener.enterCaseExpressionExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpressionExpression" ):
                listener.exitCaseExpressionExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpressionExpression" ):
                return visitor.visitCaseExpressionExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpressionExpression(self):

        localctx = intel_operation_languageParser.CaseExpressionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_caseExpressionExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.expression()
            self.state = 182
            self.match(intel_operation_languageParser.Colon)
            self.state = 183
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefineExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE(self):
            return self.getToken(intel_operation_languageParser.DEFINE, 0)

        def functionExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.FunctionExpressionContext,0)


        def CurlyLeft(self):
            return self.getToken(intel_operation_languageParser.CurlyLeft, 0)

        def RETURN(self):
            return self.getToken(intel_operation_languageParser.RETURN, 0)

        def returnExpression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ReturnExpressionContext,0)


        def CurlyRight(self):
            return self.getToken(intel_operation_languageParser.CurlyRight, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,i)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_defineExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefineExpression" ):
                listener.enterDefineExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefineExpression" ):
                listener.exitDefineExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefineExpression" ):
                return visitor.visitDefineExpression(self)
            else:
                return visitor.visitChildren(self)




    def defineExpression(self):

        localctx = intel_operation_languageParser.DefineExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_defineExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(intel_operation_languageParser.DEFINE)
            self.state = 186
            self.functionExpression()
            self.state = 187
            self.match(intel_operation_languageParser.CurlyLeft)
            self.state = 189 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 188
                self.expression()
                self.state = 191 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 7398138562179080) != 0)):
                    break

            self.state = 193
            self.match(intel_operation_languageParser.RETURN)
            self.state = 194
            self.returnExpression()
            self.state = 195
            self.match(intel_operation_languageParser.CurlyRight)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(intel_operation_languageParser.ExpressionContext,0)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_returnExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnExpression" ):
                listener.enterReturnExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnExpression" ):
                listener.exitReturnExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnExpression" ):
                return visitor.visitReturnExpression(self)
            else:
                return visitor.visitChildren(self)




    def returnExpression(self):

        localctx = intel_operation_languageParser.ReturnExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_returnExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operator(self):
            return self.getTypedRuleContext(intel_operation_languageParser.OperatorContext,0)


        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.VariableContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.VariableContext,i)


        def INT(self, i:int=None):
            if i is None:
                return self.getTokens(intel_operation_languageParser.INT)
            else:
                return self.getToken(intel_operation_languageParser.INT, i)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = intel_operation_languageParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_comparison)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 199
                self.variable()
                pass
            elif token in [52]:
                self.state = 200
                self.match(intel_operation_languageParser.INT)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 203
            self.operator()
            self.state = 206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51]:
                self.state = 204
                self.variable()
                pass
            elif token in [52]:
                self.state = 205
                self.match(intel_operation_languageParser.INT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(intel_operation_languageParser.NAME)
            else:
                return self.getToken(intel_operation_languageParser.NAME, i)

        def accessoperator(self):
            return self.getTypedRuleContext(intel_operation_languageParser.AccessoperatorContext,0)


        def Dot(self):
            return self.getToken(intel_operation_languageParser.Dot, 0)

        def variable(self):
            return self.getTypedRuleContext(intel_operation_languageParser.VariableContext,0)


        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = intel_operation_languageParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_variable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 208
                    self.match(intel_operation_languageParser.NAME)

                else:
                    raise NoViableAltException(self)
                self.state = 211 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 213
                self.accessoperator()


            self.state = 218
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==10:
                self.state = 216
                self.match(intel_operation_languageParser.Dot)
                self.state = 217
                self.variable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccessoperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def accessoperatorname(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(intel_operation_languageParser.AccessoperatornameContext)
            else:
                return self.getTypedRuleContext(intel_operation_languageParser.AccessoperatornameContext,i)


        def Colon(self):
            return self.getToken(intel_operation_languageParser.Colon, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_accessoperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessoperator" ):
                listener.enterAccessoperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessoperator" ):
                listener.exitAccessoperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessoperator" ):
                return visitor.visitAccessoperator(self)
            else:
                return visitor.visitChildren(self)




    def accessoperator(self):

        localctx = intel_operation_languageParser.AccessoperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_accessoperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.match(intel_operation_languageParser.T__0)
            self.state = 222 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 221
                self.accessoperatorname()
                self.state = 224 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 6755399441334272) != 0)):
                    break

            self.state = 232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==8:
                self.state = 226
                self.match(intel_operation_languageParser.Colon)
                self.state = 228 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 227
                    self.accessoperatorname()
                    self.state = 230 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 6755399441334272) != 0)):
                        break



            self.state = 234
            self.match(intel_operation_languageParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AccessoperatornameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(intel_operation_languageParser.VariableContext,0)


        def INT(self):
            return self.getToken(intel_operation_languageParser.INT, 0)

        def Plus(self):
            return self.getToken(intel_operation_languageParser.Plus, 0)

        def Star(self):
            return self.getToken(intel_operation_languageParser.Star, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_accessoperatorname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAccessoperatorname" ):
                listener.enterAccessoperatorname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAccessoperatorname" ):
                listener.exitAccessoperatorname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAccessoperatorname" ):
                return visitor.visitAccessoperatorname(self)
            else:
                return visitor.visitChildren(self)




    def accessoperatorname(self):

        localctx = intel_operation_languageParser.AccessoperatornameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_accessoperatorname)
        self._la = 0 # Token type
        try:
            self.state = 241
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [51, 52]:
                self.enterOuterAlt(localctx, 1)
                self.state = 238
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [51]:
                    self.state = 236
                    self.variable()
                    pass
                elif token in [52]:
                    self.state = 237
                    self.match(intel_operation_languageParser.INT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [14, 18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 240
                _la = self._input.LA(1)
                if not(_la==14 or _la==18):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Plus(self):
            return self.getToken(intel_operation_languageParser.Plus, 0)

        def Minus(self):
            return self.getToken(intel_operation_languageParser.Minus, 0)

        def Equal(self):
            return self.getToken(intel_operation_languageParser.Equal, 0)

        def Star(self):
            return self.getToken(intel_operation_languageParser.Star, 0)

        def Div(self):
            return self.getToken(intel_operation_languageParser.Div, 0)

        def Mod(self):
            return self.getToken(intel_operation_languageParser.Mod, 0)

        def Less(self):
            return self.getToken(intel_operation_languageParser.Less, 0)

        def Greater(self):
            return self.getToken(intel_operation_languageParser.Greater, 0)

        def EqualEqual(self):
            return self.getToken(intel_operation_languageParser.EqualEqual, 0)

        def And(self):
            return self.getToken(intel_operation_languageParser.And, 0)

        def Or(self):
            return self.getToken(intel_operation_languageParser.Or, 0)

        def Not(self):
            return self.getToken(intel_operation_languageParser.Not, 0)

        def XOR(self):
            return self.getToken(intel_operation_languageParser.XOR, 0)

        def AND(self):
            return self.getToken(intel_operation_languageParser.AND, 0)

        def AndAnd(self):
            return self.getToken(intel_operation_languageParser.AndAnd, 0)

        def MinusMinus(self):
            return self.getToken(intel_operation_languageParser.MinusMinus, 0)

        def getRuleIndex(self):
            return intel_operation_languageParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = intel_operation_languageParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_operator)
        try:
            self.state = 263
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 243
                self.match(intel_operation_languageParser.Plus)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 244
                self.match(intel_operation_languageParser.Minus)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 245
                self.match(intel_operation_languageParser.Equal)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 246
                self.match(intel_operation_languageParser.Star)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 247
                self.match(intel_operation_languageParser.Div)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 248
                self.match(intel_operation_languageParser.Mod)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 249
                self.match(intel_operation_languageParser.Less)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 250
                self.match(intel_operation_languageParser.Greater)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 251
                self.match(intel_operation_languageParser.EqualEqual)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 252
                self.match(intel_operation_languageParser.Less)
                self.state = 253
                self.match(intel_operation_languageParser.Equal)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 254
                self.match(intel_operation_languageParser.Greater)
                self.state = 255
                self.match(intel_operation_languageParser.Equal)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 256
                self.match(intel_operation_languageParser.And)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 257
                self.match(intel_operation_languageParser.Or)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 258
                self.match(intel_operation_languageParser.Not)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 259
                self.match(intel_operation_languageParser.XOR)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 260
                self.match(intel_operation_languageParser.AND)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 261
                self.match(intel_operation_languageParser.AndAnd)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 262
                self.match(intel_operation_languageParser.MinusMinus)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





